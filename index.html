<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#f5f5f5">
    <title>Squared</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="screens">
    <div id="homeScreen" class="screen home-screen active">
        <div class="home-core">
            <div class="decorative-squares">
                <div class="decorative-pattern top-right">
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                </div>

                <div class="decorative-pattern top-right-small">
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                </div>

                <div class="decorative-pattern middle-left">
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                </div>

                <div class="decorative-pattern middle-right">
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                </div>

                <div class="decorative-pattern bottom-left">
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                </div>

                <div class="decorative-pattern bottom-left-small">
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                </div>

                <div class="decorative-pattern bottom-right">
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                    <div class="decorative-square"></div>
                </div>
            </div>

            <div class="logo-container">
                <div class="logo-icon">
                    <div class="logo-square"></div>
                    <div class="logo-square hollow"></div>
                    <div class="logo-square hollow"></div>
                    <div class="logo-square"></div>
                </div>
                <p style="font-size: 42px;">Squared</p>
            </div>

            <div class="menu">
                <button class="menu-button" onclick="showGame()">
                    <div class="menu-icon">
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                    </div>
                    Play
                </button>
                <!--<button class="menu-button" onclick="alert('Stats coming soon!')">
                    <div class="menu-icon">
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                    </div>
                    Stats
                </button> -->
                <button class="menu-button" onclick="showTutorial()">
                    <div class="menu-icon">
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                    </div>
                    Tutorial
                </button>
                <button class="menu-button" onclick="showMore()">
                    <div class="menu-icon">
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                        <div class="menu-icon-square"></div>
                    </div>
                    More
                </button>
            </div>
        </div>
    </div>

    <div id="tutorialScreen" class="screen tutorial-screen">
        <header class="screen-header">
            <button class="back-btn" onclick="showHome()">
                <svg viewBox="0 0 24 24" width="24" height="24">
                    <path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                </svg>
            </button>
            <h2>Tutorial</h2>
        </header>
        <div class="screen-content">
            <div class="tutorial-tabs">
                <button class="tutorial-tab active" data-tab="basics" onclick="setActiveTutorialTab('basics')">basics</button>
                <button class="tutorial-tab" data-tab="extras" onclick="setActiveTutorialTab('extras')">extras</button>
            </div>

            <div id="tutorialBasics" class="tutorial-tab-panel active" data-tab-panel="basics">
                <div class="tutorial-top">
                    <div class="tutorial-description">
                        <p>Find four squares that match the pattern and form the corners of a larger square.</p>
                    </div>
                </div>

                <div class="tutorial-grid-wrapper">
                    <div class="tutorial-pattern-block">
                        <div class="pattern-label">Pattern to match</div>
                        <div class="pattern" id="tutorialPattern"></div>
                    </div>
                    <div id="tutorialMessage" class="tutorial-message"></div>
                    <div id="tutorialGrid" class="tutorial-grid"></div>
                </div>
            </div>

            <div id="tutorialExtras" class="tutorial-tab-panel" data-tab-panel="extras">
                <div class="tutorial-packs">
                    <div class="tutorial-pack">
                        <div class="tutorial-pack-title">Hints</div>
                        <div class="tutorial-pack-description">Reveal a square within the current pattern so you can lock in on the right spot faster.</div>
                    </div>
                    <div class="tutorial-pack">
                        <div class="tutorial-pack-title">Skips</div>
                        <div class="tutorial-pack-description">Move on to a brand new pattern with no penalty if the current board feels tricky.</div>
                    </div>
                    <div class="tutorial-pack">
                        <div class="tutorial-pack-title">Time +</div>
                        <div class="tutorial-pack-description">Pause the countdown timer long enough to finish the pattern without pressure.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="moreScreen" class="screen more-screen-wrapper">
        <header class="screen-header">
            <button class="back-btn" onclick="showHome()">
                <svg viewBox="0 0 24 24" width="24" height="24">
                    <path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                </svg>
            </button>
            <h2>MORE</h2>
        </header>
        <div class="screen-content">
        
        <div class="more-tabs">
            <button class="more-tab active" onclick="showSettingsTab()">settings</button>
            <button class="more-tab" onclick="showAboutTab()">about</button>
        </div>
        
        <div id="settingsTab">
            <div class="settings-section">
                <div class="setting-label">theme</div>
                <div class="theme-options">
                    <div class="theme-option selected" data-theme="0" onclick="selectTheme(0)">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #7FD45E;"></div>
                            <div class="theme-color" style="background: #E8479D;"></div>
                            <div class="theme-color" style="background: #FFA826;"></div>
                            <div class="theme-color" style="background: #1E9FD8;"></div>
                            <div class="theme-color" style="background: #7E8FD4;"></div>
                        </div>
                        <div class="theme-radio selected"></div>
                    </div>
                    <div class="theme-option" data-theme="1" onclick="selectTheme(1)">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #F5A623;"></div>
                            <div class="theme-color" style="background: #7ED4D1;"></div>
                            <div class="theme-color" style="background: #EC8C99;"></div>
                            <div class="theme-color" style="background: #8FD47E;"></div>
                            <div class="theme-color" style="background: #C96565;"></div>
                        </div>
                        <div class="theme-radio"></div>
                    </div>
                    <div class="theme-option" data-theme="2" onclick="selectTheme(2)">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #6B9370;"></div>
                            <div class="theme-color" style="background: #B5D4A1;"></div>
                            <div class="theme-color" style="background: #A8CEE2;"></div>
                            <div class="theme-color" style="background: #D4C89E;"></div>
                            <div class="theme-color" style="background: #E8B4B8;"></div>
                        </div>
                        <div class="theme-radio"></div>
                    </div>
                    <div class="theme-option" data-theme="3" onclick="selectTheme(3)">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #2D3436;"></div>
                            <div class="theme-color" style="background: #4A5F8C;"></div>
                            <div class="theme-color" style="background: #B8C5E0;"></div>
                            <div class="theme-color" style="background: #F4E63D;"></div>
                            <div class="theme-color" style="background: #9BA653;"></div>
                        </div>
                        <div class="theme-radio"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="aboutTab" style="display: none;">
            <p style="margin-bottom: 20px;">created by: <strong>Austin Laugesen</strong></p>
            <p style="margin-bottom: 20px;">email: <a href="mailto:alaug@outlook.com" style="color: #1E9FD8; text-decoration: none;">alaug@outlook.com</a></p>
            <p style="margin-bottom: 20px;">version: 1.2026.01.01</p>
            
        </div>
        </div>
    </div>

    <div id="gameContainer" class="screen game-screen">
        <header class="screen-header">
            <button class="back-btn" onclick="backToHome()">
                <svg viewBox="0 0 24 24" width="24" height="24">
                    <path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                </svg>
            </button>
            <h2>Play</h2>
        </header>
        <div class="screen-content">
            <div id="gameScreen">
            <div class="top-section">
                <div class="timer-section">
                    <div class="timer">time <span id="timer">60</span>s</div>
                </div>
                
                <div class="pattern-section">
                    <div class="pattern-container">
                        <div class="pattern" id="pattern"></div>
                    </div>
                </div>
                
                <div class="score-section">
                    <div class="score">score <span id="score">0</span></div>
                </div>
            </div>

            <div class="message" id="message"></div>

            <div class="grid" id="grid"></div>

            <div class="game-actions">
                <div class="action-item" id="hintsAction" onclick="useHint()">
                    <div class="action-count"><span id="hintsCount">5</span></div>
                    <div class="action-label">hints</div>
                </div>
                <div class="action-item" id="skipsAction" onclick="useSkip()">
                    <div class="action-count"><span id="skipsCount">5</span></div>
                    <div class="action-label">skips</div>
                </div>
                <div class="action-item" id="timePlussAction" onclick="usetimePlus()">
                    <div class="action-count"><span id="timePlussCount">5</span></div>
                    <div class="action-label">time +</div>
                </div>
            </div>
        </div>

        <div id="gameOverScreen" style="display: none;" class="game-over">
            <h2>Game Over!</h2>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <button class="button" onclick="startGame()">Play Again</button>
        </div>
        </div>
    </div>
    </div>

    <script>
        // Color themes matching the More page
        const COLOR_THEMES = [
            ['#7FD45E', '#E8479D', '#FFA826', '#1E9FD8', '#7E8FD4'], // Theme 0 - Default
            ['#F5A623', '#7ED4D1', '#EC8C99', '#8FD47E', '#C96565'], // Theme 1
            ['#6B9370', '#B5D4A1', '#A8CEE2', '#D4C89E', '#E8B4B8'], // Theme 2
            ['#2D3436', '#4A5F8C', '#B8C5E0', '#F4E63D', '#9BA653']  // Theme 3
        ];
        
        const GRID_SIZE = 5;
        const TUTORIAL_GRID_SIZE = 5;
        let grid = [];
        let pattern = [];
        let selectedSquares = [];
        let score = 0;
        let timeLeft = 60;
        let timer = null;
        let validSolutions = [];
        let hintSquare = null;
        let selectedThemeIndex = 0;
        let currentColors = COLOR_THEMES[0];
        let hintsRemaining = 5;
        let skipsRemaining = 5;
        let timePlussRemaining = 5;
        let prevLeftX = -1;
        let prevTopY = -1;
        let prevRightX = -1;
        let infiniteLoopMitigationIndex = 0;
        let currentSolutionCoords = [];
        let decorativeSquares = [];
        let hiddenDecorativeSquares = [];
        let decorativeTimer = null;
        let decorativeTimerCount = 0;
        let tutorialGrid = [];
        let tutorialPattern = [];
        let tutorialSquares = [];
        let tutorialCurrentSolutionCoords = [];
        let tutorialTimer = null;
        let tutorialAnimationCount = 0;
        let tutorialPrevLeftX = -1;
        let tutorialPrevTopY = -1;
        let tutorialPrevRightX = -1;
        let tutorialInfiniteLoopIndex = 0;

        function showHome() {
            document.getElementById('homeScreen').classList.add('active');
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('moreScreen').classList.remove('active');
            document.getElementById('tutorialScreen').classList.remove('active');
            document.body.classList.remove('game-active');
            stopTutorialAnimation();
            startDecorativeTimer();
        }

        function backToHome() {
            clearInterval(timer);
            showHome();
        }

        function showMore() {
            document.getElementById('homeScreen').classList.remove('active');
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('moreScreen').classList.add('active');
            document.getElementById('tutorialScreen').classList.remove('active');
            stopDecorativeTimer();
            stopTutorialAnimation();
        }

        function showTutorial() {
            document.getElementById('homeScreen').classList.remove('active');
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('moreScreen').classList.remove('active');
            document.getElementById('tutorialScreen').classList.add('active');
            document.body.classList.add('game-active');
            stopDecorativeTimer();
            setActiveTutorialTab('basics');
        }

        function showSettingsTab() {
            document.querySelectorAll('.more-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('settingsTab').style.display = 'block';
            document.getElementById('aboutTab').style.display = 'none';
        }

        function showAboutTab() {
            document.querySelectorAll('.more-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('settingsTab').style.display = 'none';
            document.getElementById('aboutTab').style.display = 'block';
        }

        function setActiveTutorialTab(tabKey) {
            const tabs = document.querySelectorAll('.tutorial-tab');
            tabs.forEach(tab => {
                const isActive = tab.dataset.tab === tabKey;
                tab.classList.toggle('active', isActive);
            });

            const panels = document.querySelectorAll('.tutorial-tab-panel');
            panels.forEach(panel => {
                const isActive = panel.dataset.tabPanel === tabKey;
                panel.classList.toggle('active', isActive);
                panel.style.display = isActive ? 'block' : 'none';
            });

            if (tabKey === 'basics') {
                startTutorial();
            } else {
                stopTutorialAnimation();
            }
        }

        function selectTheme(index) {
            selectedThemeIndex = index;
            currentColors = COLOR_THEMES[index];
            // Update theme-option selected state
            document.querySelectorAll('.theme-option').forEach((option, i) => {
                if (i === index) {
                    option.classList.add('selected');
                    option.querySelector('.theme-radio').classList.add('selected');
                } else {
                    option.classList.remove('selected');
                    option.querySelector('.theme-radio').classList.remove('selected');
                }
            });
        }

        function initDecorativeSquares() {
            decorativeSquares = Array.from(document.querySelectorAll('.decorative-square'));
            hiddenDecorativeSquares = [];
            decorativeTimerCount = 0;
            decorativeSquares.forEach(square => {
                square.classList.remove('hidden');
                square.dataset.visible = 'true';
            });
        }

        function startDecorativeTimer() {
            if (decorativeSquares.length === 0) {
                initDecorativeSquares();
            }
            if (decorativeTimer) {
                return;
            }
            decorativeTimer = setInterval(decorativeTimerTick, 750);
        }

        function stopDecorativeTimer() {
            if (decorativeTimer) {
                clearInterval(decorativeTimer);
                decorativeTimer = null;
            }
        }

        function hideDecorativeSquare(square) {
            if (!square || square.dataset.visible === 'false') {
                return;
            }
            square.classList.add('hidden');
            square.dataset.visible = 'false';
            hiddenDecorativeSquares.push(square);
        }

        function showDecorativeSquare(square) {
            if (!square) {
                return;
            }
            square.classList.remove('hidden');
            square.dataset.visible = 'true';
        }

        function decorativeTimerTick() {
            if (decorativeSquares.length === 0) {
                return;
            }

            let index = Math.floor(Math.random() * decorativeSquares.length);
            let square = decorativeSquares[index];

            if (index % 2 === 0) {
                if (decorativeTimerCount % 2 === 0) {
                    if (index === 0) {
                        index = Math.min(index + 1, decorativeSquares.length - 1);
                    } else {
                        index = index - 1;
                    }
                    square = decorativeSquares[index];
                    decorativeTimerCount = 0;
                }

                if (square.dataset.visible === 'true') {
                    hideDecorativeSquare(square);
                }
            } else {
                if (hiddenDecorativeSquares.length > 0) {
                    const next = hiddenDecorativeSquares.shift();
                    showDecorativeSquare(next);
                }
            }

            decorativeTimerCount++;
        }

        function startTutorial() {
            stopTutorialAnimation();

            tutorialAnimationCount = 0;
            tutorialPrevLeftX = -1;
            tutorialPrevTopY = -1;
            tutorialPrevRightX = -1;
            tutorialInfiniteLoopIndex = 0;
            tutorialPattern = [];
            tutorialCurrentSolutionCoords = [];

            tutorialGrid = [];
            for (let i = 0; i < TUTORIAL_GRID_SIZE * TUTORIAL_GRID_SIZE; i++) {
                tutorialGrid.push(currentColors[Math.floor(Math.random() * currentColors.length)]);
            }

            renderTutorialGrid();
            tutorialPickSolution();

            tutorialTimer = setInterval(() => {
                tutorialPickSolution();
            }, 4500);
        }

        function stopTutorialAnimation() {
            if (tutorialTimer) {
                clearInterval(tutorialTimer);
                tutorialTimer = null;
            }
            tutorialAnimationCount = 0;
            tutorialPrevLeftX = -1;
            tutorialPrevTopY = -1;
            tutorialPrevRightX = -1;
            tutorialCurrentSolutionCoords = [];
            if (tutorialSquares.length > 0) {
                tutorialSquares.forEach(square => square.classList.remove('highlight'));
            }
            const message = document.getElementById('tutorialMessage');
            if (message) {
                message.style.opacity = 0;
                message.textContent = '';
            }
            const patternElement = document.getElementById('tutorialPattern');
            if (patternElement) {
                patternElement.innerHTML = '';
            }
        }

        function renderTutorialGrid() {
            const gridElement = document.getElementById('tutorialGrid');
            if (!gridElement) {
                return;
            }
            gridElement.innerHTML = '';
            tutorialSquares = [];

            tutorialGrid.forEach(color => {
                const square = document.createElement('div');
                square.className = 'tutorial-square';
                square.style.backgroundColor = color;
                gridElement.appendChild(square);
                tutorialSquares.push(square);
            });
        }

        function renderTutorialPattern() {
            const patternElement = document.getElementById('tutorialPattern');
            if (!patternElement) {
                return;
            }
            patternElement.innerHTML = '';
            tutorialPattern.forEach(color => {
                const square = document.createElement('div');
                square.className = 'pattern-square';
                square.style.backgroundColor = color;
                patternElement.appendChild(square);
            });
        }

        function tutorialPickSolution() {
            if (tutorialGrid.length === 0) {
                return;
            }

            const sideLength = (tutorialAnimationCount % 2 === 0) ? 0 : 2;
            tutorialGetNewPatternToSolve(sideLength);
            renderTutorialPattern();
            highlightTutorialSquares();
            updateTutorialMessage(sideLength);
            tutorialAnimationCount++;
        }

        function highlightTutorialSquares() {
            if (tutorialSquares.length === 0) {
                return;
            }

            tutorialSquares.forEach(square => square.classList.remove('highlight'));
            tutorialCurrentSolutionCoords.forEach(index => {
                if (tutorialSquares[index]) {
                    tutorialSquares[index].classList.add('highlight');
                }
            });
        }

        function updateTutorialMessage(sideLength) {
            const message = document.getElementById('tutorialMessage');
            if (!message) {
                return;
            }

            let text = '';
            if (tutorialCurrentSolutionCoords.length === 0) {
                message.style.opacity = 0;
                message.textContent = text;
                return;
            }

            if (sideLength === 0) {
                text = 'Equidistant squares make a larger outline.';
            } else {
                text = 'Grouped squares share edges.';
            }

            message.textContent = text;
            message.style.opacity = 1;
        }

        function tutorialGetNewPatternToSolve(sideLength) {
            if (tutorialGrid.length !== TUTORIAL_GRID_SIZE * TUTORIAL_GRID_SIZE) {
                tutorialPattern = [];
                tutorialCurrentSolutionCoords = [];
                return;
            }

            let internalSideLength = sideLength;
            let startX = 0;
            let startY = 0;
            let leftX = 0;
            let rightX = 0;
            let topY = 0;
            let bottomY = 0;
            let shouldBreak = false;
            let loopCount = 0;

            do {
                do {
                    startX = randomIntInclusive(0, TUTORIAL_GRID_SIZE - 1);
                    startY = randomIntInclusive(0, TUTORIAL_GRID_SIZE - 1);

                    if (sideLength === -1) {
                        internalSideLength = randomIntInclusive(1, Math.max(1, TUTORIAL_GRID_SIZE - startX - 1));
                    } else if (sideLength === 0) {
                        internalSideLength = randomIntInclusive(2, Math.max(2, TUTORIAL_GRID_SIZE - 2));
                    } else {
                        internalSideLength = 1;
                    }

                    const mitigation = tutorialInfiniteLoopMitigation(loopCount, {
                        startX,
                        startY,
                        sideLength: internalSideLength,
                        shouldBreak
                    });
                    startX = mitigation.startX;
                    startY = mitigation.startY;
                    internalSideLength = mitigation.sideLength;
                    shouldBreak = mitigation.shouldBreak;

                    if (!shouldBreak) {
                        const xValues = getLeftAndRightXValues(startX, sideLength, internalSideLength);
                        leftX = xValues.leftX;
                        rightX = xValues.rightX;
                        internalSideLength = xValues.sideLength;
                    } else {
                        const xValues = getLeftAndRightXValuesSimple(startX, internalSideLength);
                        leftX = xValues.leftX;
                        rightX = xValues.rightX;
                    }

                    const yValues = getTopAndBottomYValues(startY, internalSideLength);
                    topY = yValues.topY;
                    bottomY = yValues.bottomY;

                    loopCount++;
                } while (
                    tutorialAreCoordinatesOutsideBounds(bottomY, rightX, leftX, topY) ||
                    tutorialAreCoordinatesSameAsLastRound(leftX, topY, rightX)
                );

                const topLeftIdx = topY * TUTORIAL_GRID_SIZE + leftX;
                const topRightIdx = topY * TUTORIAL_GRID_SIZE + rightX;
                const bottomLeftIdx = bottomY * TUTORIAL_GRID_SIZE + leftX;
                const bottomRightIdx = bottomY * TUTORIAL_GRID_SIZE + rightX;

                if (!areOneOrMoreSquaresAnimating()) {
                    tutorialInfiniteLoopIndex = 0;
                    tutorialPrevLeftX = leftX;
                    tutorialPrevTopY = topY;
                    tutorialPrevRightX = rightX;

                    tutorialPattern = [
                        tutorialGrid[topLeftIdx],
                        tutorialGrid[topRightIdx],
                        tutorialGrid[bottomLeftIdx],
                        tutorialGrid[bottomRightIdx]
                    ];

                    tutorialCurrentSolutionCoords = [topLeftIdx, topRightIdx, bottomLeftIdx, bottomRightIdx];
                    return;
                }
            } while (true);
        }

        function tutorialInfiniteLoopMitigation(loopCount, state) {
            let { startX, startY, sideLength, shouldBreak } = state;
            if (loopCount !== 0 && loopCount % 5 === 0) {
                shouldBreak = false;
                switch (tutorialGetIndexForInfiniteLoopMitigationTechnique()) {
                    case 0:
                        startX = 0;
                        startY = 0;
                        break;
                    case 1:
                        startX = TUTORIAL_GRID_SIZE - 1;
                        startY = 0;
                        break;
                    case 2:
                        startX = 0;
                        startY = TUTORIAL_GRID_SIZE - 1;
                        break;
                    case 3:
                        startX = TUTORIAL_GRID_SIZE - 1;
                        startY = TUTORIAL_GRID_SIZE - 1;
                        break;
                    case 4:
                        startX = 0;
                        startY = 0;
                        sideLength = 1;
                        break;
                    case 5:
                        startX = TUTORIAL_GRID_SIZE - 1;
                        startY = 0;
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    case 6:
                        startX = 0;
                        startY = TUTORIAL_GRID_SIZE - 1;
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    case 7:
                        startX = TUTORIAL_GRID_SIZE - 1;
                        startY = TUTORIAL_GRID_SIZE - 1;
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    case 8:
                        startX = Math.floor(TUTORIAL_GRID_SIZE / 2);
                        startY = Math.floor(TUTORIAL_GRID_SIZE / 2);
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    default:
                        break;
                }
            }
            return { startX, startY, sideLength, shouldBreak };
        }

        function tutorialGetIndexForInfiniteLoopMitigationTechnique() {
            const current = tutorialInfiniteLoopIndex;
            tutorialInfiniteLoopIndex = tutorialInfiniteLoopIndex === 8 ? 0 : tutorialInfiniteLoopIndex + 1;
            return current;
        }

        function tutorialAreCoordinatesOutsideBounds(bottomY, rightX, leftX, topY) {
            return bottomY >= TUTORIAL_GRID_SIZE ||
                rightX >= TUTORIAL_GRID_SIZE ||
                leftX < 0 ||
                topY < 0;
        }

        function tutorialAreCoordinatesSameAsLastRound(newLeftX, newTopY, newRightX) {
            return newLeftX === tutorialPrevLeftX &&
                newTopY === tutorialPrevTopY &&
                newRightX === tutorialPrevRightX;
        }

        function showGame() {
            document.getElementById('homeScreen').classList.remove('active');
            document.getElementById('moreScreen').classList.remove('active');
            document.getElementById('tutorialScreen').classList.remove('active');
            document.getElementById('gameContainer').classList.add('active');
            document.body.classList.add('game-active');
            stopDecorativeTimer();
            stopTutorialAnimation();
            startGame();
        }

        function startGame() {
            score = 0;
            timeLeft = 60;
            selectedSquares = [];
            hintsRemaining = 5;
            skipsRemaining = 5;
            timePlussRemaining = 5;
            prevLeftX = -1;
            prevTopY = -1;
            prevRightX = -1;
            infiniteLoopMitigationIndex = 0;
            currentSolutionCoords = [];
            validSolutions = [];
            
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            updateDisplay();
            generateLevel();
        }

        function generateLevel() {
            clearInterval(timer);
            selectedSquares = [];
            hintSquare = null;
            timeLeft = 60;
            
            // Generate random grid
            grid = [];
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                grid.push(currentColors[Math.floor(Math.random() * currentColors.length)]);
            }

            // Generate pattern using board square corners
            getNewPatternToSolve(-1);

            renderGrid();
            renderPattern();
            updateDisplay();
            startTimer();
        }

        // Port of Board.GetNewPatternToSolve from the original game to select square corners without repeats.
        function getNewPatternToSolve(sideLength = -1) {
            if (grid.length !== GRID_SIZE * GRID_SIZE) {
                pattern = [];
                currentSolutionCoords = [];
                validSolutions = [];
                return;
            }

            let internalSideLength = sideLength;
            let startX = 0;
            let startY = 0;
            let leftX = 0;
            let rightX = 0;
            let topY = 0;
            let bottomY = 0;
            let shouldBreak = false;
            let loopCount = 0;

            do {
                do {
                    startX = randomIntInclusive(0, GRID_SIZE - 1);
                    startY = randomIntInclusive(0, GRID_SIZE - 1);

                    if (sideLength === -1) {
                        internalSideLength = randomIntInclusive(1, Math.max(1, GRID_SIZE - startX - 1));
                    } else if (sideLength === 0) {
                        internalSideLength = randomIntInclusive(2, Math.max(2, GRID_SIZE - 2));
                    } else {
                        internalSideLength = 1;
                    }

                    const mitigation = infiniteLoopMitigation(loopCount, {
                        startX,
                        startY,
                        sideLength: internalSideLength,
                        shouldBreak
                    });
                    startX = mitigation.startX;
                    startY = mitigation.startY;
                    internalSideLength = mitigation.sideLength;
                    shouldBreak = mitigation.shouldBreak;

                    if (!shouldBreak) {
                        const xValues = getLeftAndRightXValues(startX, sideLength, internalSideLength);
                        leftX = xValues.leftX;
                        rightX = xValues.rightX;
                        internalSideLength = xValues.sideLength;
                    } else {
                        const xValues = getLeftAndRightXValuesSimple(startX, internalSideLength);
                        leftX = xValues.leftX;
                        rightX = xValues.rightX;
                    }

                    const yValues = getTopAndBottomYValues(startY, internalSideLength);
                    topY = yValues.topY;
                    bottomY = yValues.bottomY;

                    loopCount++;
                } while (
                    areCoordinatesOutsideBoundsOfBoard(bottomY, rightX, leftX, topY) ||
                    areCoordinatesSameAsLastRound(leftX, topY, rightX)
                );

                const topLeftIdx = topY * GRID_SIZE + leftX;
                const topRightIdx = topY * GRID_SIZE + rightX;
                const bottomLeftIdx = bottomY * GRID_SIZE + leftX;
                const bottomRightIdx = bottomY * GRID_SIZE + rightX;

                if (!areOneOrMoreSquaresAnimating()) {
                    infiniteLoopMitigationIndex = 0;
                    prevLeftX = leftX;
                    prevTopY = topY;
                    prevRightX = rightX;

                    pattern = [
                        grid[topLeftIdx],
                        grid[topRightIdx],
                        grid[bottomLeftIdx],
                        grid[bottomRightIdx]
                    ];

                    currentSolutionCoords = [topLeftIdx, topRightIdx, bottomLeftIdx, bottomRightIdx];
                    validSolutions = [currentSolutionCoords.slice()];
                    return;
                }
            } while (true);
        }

        function randomIntInclusive(min, max) {
            if (max < min) {
                return min;
            }
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function infiniteLoopMitigation(loopCount, state) {
            let { startX, startY, sideLength, shouldBreak } = state;
            if (loopCount !== 0 && loopCount % 5 === 0) {
                shouldBreak = false;
                switch (getIndexForInfiniteLoopMitigationTechnique()) {
                    case 0:
                        startX = 0;
                        startY = 0;
                        break;
                    case 1:
                        startX = GRID_SIZE - 1;
                        startY = 0;
                        break;
                    case 2:
                        startX = 0;
                        startY = GRID_SIZE - 1;
                        break;
                    case 3:
                        startX = GRID_SIZE - 1;
                        startY = GRID_SIZE - 1;
                        break;
                    case 4:
                        startX = 0;
                        startY = 0;
                        sideLength = 1;
                        break;
                    case 5:
                        startX = GRID_SIZE - 1;
                        startY = 0;
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    case 6:
                        startX = 0;
                        startY = GRID_SIZE - 1;
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    case 7:
                        startX = GRID_SIZE - 1;
                        startY = GRID_SIZE - 1;
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    case 8:
                        startX = Math.floor(GRID_SIZE / 2);
                        startY = Math.floor(GRID_SIZE / 2);
                        sideLength = 1;
                        shouldBreak = true;
                        break;
                    default:
                        break;
                }
            }
            return { startX, startY, sideLength, shouldBreak };
        }

        function getIndexForInfiniteLoopMitigationTechnique() {
            const current = infiniteLoopMitigationIndex;
            infiniteLoopMitigationIndex = infiniteLoopMitigationIndex === 8 ? 0 : infiniteLoopMitigationIndex + 1;
            return current;
        }

        function getLeftAndRightXValues(startX, originalSideLength, sideLength) {
            let leftX;
            let rightX;
            let adjustedSideLength = Math.max(1, sideLength);

            if ((GRID_SIZE / 2) < startX) {
                rightX = startX;
                if (originalSideLength === 0) {
                    while (rightX - adjustedSideLength < 0 && adjustedSideLength > 1) {
                        adjustedSideLength--;
                    }
                }
                leftX = rightX - adjustedSideLength;
            } else {
                leftX = startX;
                if (originalSideLength === 0) {
                    while (leftX + adjustedSideLength >= GRID_SIZE && adjustedSideLength > 1) {
                        adjustedSideLength--;
                    }
                }
                rightX = leftX + adjustedSideLength;
            }

            return {
                leftX,
                rightX,
                sideLength: Math.max(1, adjustedSideLength)
            };
        }

        function getLeftAndRightXValuesSimple(startX, sideLength) {
            const adjustedSideLength = Math.max(1, sideLength);
            if ((GRID_SIZE / 2) < startX) {
                const rightX = startX;
                const leftX = rightX - adjustedSideLength;
                return { leftX, rightX };
            }
            const leftX = startX;
            const rightX = leftX + adjustedSideLength;
            return { leftX, rightX };
        }

        function getTopAndBottomYValues(startY, sideLength) {
            const adjustedSideLength = Math.max(1, sideLength);
            if ((GRID_SIZE / 2) < startY) {
                const bottomY = startY;
                const topY = bottomY - adjustedSideLength;
                return { topY, bottomY };
            }
            const topY = startY;
            const bottomY = topY + adjustedSideLength;
            return { topY, bottomY };
        }

        function areCoordinatesOutsideBoundsOfBoard(bottomY, rightX, leftX, topY) {
            return bottomY >= GRID_SIZE ||
                rightX >= GRID_SIZE ||
                leftX < 0 ||
                topY < 0;
        }

        function areCoordinatesSameAsLastRound(newLeftX, newTopY, newRightX) {
            return newLeftX === prevLeftX &&
                newTopY === prevTopY &&
                newRightX === prevRightX;
        }

        function areOneOrMoreSquaresAnimating() {
            return false;
        }

        function renderGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            
            grid.forEach((color, index) => {
                const square = document.createElement('div');
                square.className = 'square';
                square.style.backgroundColor = color;
                square.dataset.index = index;
                square.onclick = () => selectSquare(index);
                gridElement.appendChild(square);
            });
        }

        function renderPattern() {
            const patternElement = document.getElementById('pattern');
            patternElement.innerHTML = '';
            
            pattern.forEach(color => {
                const square = document.createElement('div');
                square.className = 'pattern-square';
                square.style.backgroundColor = color;
                patternElement.appendChild(square);
            });
        }

        function selectSquare(index) {
            if (selectedSquares.includes(index)) {
                selectedSquares = selectedSquares.filter(i => i !== index);
            } else if (selectedSquares.length < 4) {
                selectedSquares.push(index);
            }
            
            updateSquareDisplay();
            updateDisplay();
            
            if (selectedSquares.length === 4) {
                checkSolution();
            }
        }

        function updateSquareDisplay() {
            document.querySelectorAll('.square').forEach(square => {
                const index = parseInt(square.dataset.index);
                square.classList.remove('selected', 'hint');
                if (selectedSquares.includes(index)) {
                    square.classList.add('selected');
                } else if (hintSquare === index) {
                    square.classList.add('hint');
                }
            });
        }

        function checkSolution() {
            if (selectedSquares.length !== 4) return;
            
            // Get positions and colors of selected squares
            const positions = selectedSquares.map(idx => ({
                idx: idx,
                row: Math.floor(idx / GRID_SIZE),
                col: idx % GRID_SIZE,
                color: grid[idx]
            }));
            
            // Sort positions to get top-left, top-right, bottom-left, bottom-right order
            positions.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row; // Sort by row first
                return a.col - b.col; // Then by column
            });
            
            // Pattern array is: [top-left, top-right, bottom-left, bottom-right]
            // So we need to reorder sorted positions to match this pattern layout
            const topLeft = positions[0];
            const topRight = positions[1];
            const bottomLeft = positions[2];
            const bottomRight = positions[3];
            
            // Check if colors match the pattern in the correct positions
            const colorsMatch = 
                grid[topLeft.idx] === pattern[0] &&
                grid[topRight.idx] === pattern[1] &&
                grid[bottomLeft.idx] === pattern[2] &&
                grid[bottomRight.idx] === pattern[3];
            
            if (!colorsMatch) {
                // Subtle shake on wrong squares
                selectedSquares.forEach(idx => {
                    const square = document.querySelector(`[data-index="${idx}"]`);
                    square.classList.add('wrong');
                    setTimeout(() => square.classList.remove('wrong'), 400);
                });
                
                setTimeout(() => {
                    selectedSquares = [];
                    updateSquareDisplay();
                    updateDisplay();
                }, 50);
                return;
            }
            
            // Check if it's a valid solution ( equidistant)
            const isValid = isEquidistant(topLeft, topRight, bottomLeft, bottomRight);
            
            if (isValid) {
                showMessage('Perfect! âœ“', 'success');
                const points = 4; // 1 points per square
                // TODO - apply multiplier
                score += points; 
                
                setTimeout(() => {
                    showMessage('', '');
                    generateLevel();
                }, 300);
            } else {
                // Subtle shake on wrong pattern type
                selectedSquares.forEach(idx => {
                    const square = document.querySelector(`[data-index="${idx}"]`);
                    square.classList.add('wrong');
                    setTimeout(() => square.classList.remove('wrong'), 400);
                });
                
                setTimeout(() => {
                    selectedSquares = [];
                    updateSquareDisplay();
                    updateDisplay();
                }, 500);
            }
        }

        function isEquidistant(topLeft, topRight, bottomLeft, bottomRight) {
            if (!topLeft || !topRight || !bottomLeft || !bottomRight) return false;
          
            /* TODO - fix the bug in isEquidistant*/
            // Calculate distances
            // 0 and 1 are row one
            // 2 and 3 are row two
            const deltaTopRightToTopLeft = topRight.col - topLeft.col;
            const deltaBottomRightToBottomLeft = bottomRight.col - bottomLeft.col;
            const deltaBottomLeftToTopLeft = bottomLeft.row - topLeft.row;
            const deltaBottomRightToTopRight = bottomRight.row - topRight.row;

            return (deltaTopRightToTopLeft === deltaBottomRightToBottomLeft) &&
                   (deltaBottomLeftToTopLeft === deltaBottomRightToTopRight &&
                     (deltaTopRightToTopLeft === deltaBottomLeftToTopLeft));
        }

        function resetSelection() {
            selectedSquares = [];
            updateSquareDisplay();
            updateDisplay();
            showMessage('', '');
        }

        function startTimer() {
            timer = setInterval(() => {
                timeLeft--;
                updateDisplay();
                                               
                if (timeLeft <= 0) {
                    gameOver();
                }
            }, 1000);
        }

        function showHint() {
            // Pick a random valid solution and highlight the first square
            const randomSolution = validSolutions[Math.floor(Math.random() * validSolutions.length)];
            hintSquare = randomSolution[0];
            console.log('Hint square:', hintSquare, 'from solution:', randomSolution);
            updateSquareDisplay();
        }

        function gameOver() {
            clearInterval(timer);
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
        }

        function showMessage(text, type) {
            const messageEl = document.getElementById('message');
            if (text) {
                messageEl.textContent = text;
                messageEl.className = 'message ' + type + ' show';
            } else {
                messageEl.classList.remove('show');
                setTimeout(() => {
                    messageEl.textContent = '';
                    messageEl.className = 'message';
                }, 300);
            }
        }

        function updateDisplay() {
            document.getElementById('timer').textContent = timeLeft;
            document.getElementById('score').textContent = score;
            document.getElementById('hintsCount').textContent = hintsRemaining;
            document.getElementById('skipsCount').textContent = skipsRemaining;
            document.getElementById('timePlussCount').textContent = timePlussRemaining;
            
            // Update border visibility based on remaining counts
            const hintsAction = document.getElementById('hintsAction');
            const skipsAction = document.getElementById('skipsAction');
            const timePlussAction = document.getElementById('timePlussAction');
            
            if (hintsRemaining === 0) {
                hintsAction.classList.add('depleted');
            } else {
                hintsAction.classList.remove('depleted');
            }
            
            if (skipsRemaining === 0) {
                skipsAction.classList.add('depleted');
            } else {
                skipsAction.classList.remove('depleted');
            }
            
            if (timePlussRemaining === 0) {
                timePlussAction.classList.add('depleted');
            } else {
                timePlussAction.classList.remove('depleted');
            }
        }

        function useHint() {
            if (hintsRemaining > 0 && validSolutions.length > 0) {
                hintsRemaining--;
                const randomSolution = validSolutions[Math.floor(Math.random() * validSolutions.length)];
                hintSquare = randomSolution[0];
                updateSquareDisplay();
                updateDisplay();
                
                // Clear hint after 3 seconds
                setTimeout(() => {
                    hintSquare = null;
                    updateSquareDisplay();
                }, 3000);
            }
        }

        function useSkip() {
            if (skipsRemaining > 0) {
                skipsRemaining--;
                
                updateDisplay();
                generateLevel();
            }
        }

        function usetimePlus() {
            if (timePlussRemaining > 0) {
                timePlussRemaining--;
                timeLeft += 10; // Add 10 seconds
                updateDisplay();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initDecorativeSquares();
            startDecorativeTimer();
        });

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').catch((error) => {
                    console.error('Service worker registration failed:', error);
                });
            });
        }
    </script>
</body>
</html>